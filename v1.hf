#url /api/v1
#type api
#base https://w3id.org/oc
#title REST API for the OpenCitations Corpus
#description This document describe the REST API for accessing the data stored in the [OpenCitations Corpus](https://w3id.org/oc/corpus) hosted by [OpenCitations](http://opencitations.net). All the operations described in this document return either a JSON document (default) or a CSV document according to the mimetype specified in the `Accept` header of the request.

If you would like to suggest an additional operation to be included in this API, please use the [issue tracker](https://github.com/opencitations/api/issues) of the OpenCitations Corpus API available on GitHub.
#version 1.0.0
#license This document is licensed with a [Creative Commons Attribution 4.0 International License](https://creativecommons.org/licenses/by/4.0/legalcode), while the REST API itself has been created using [RAMOSE](https://github.com/opencitations/ramose), the *Restful API Manager Over SPARQL Endpoints* created by [Silvio Peroni](https://orcid.org/0000-0003-0530-4305), which is licensed with an [ISC license](https://opensource.org/licenses/ISC).
#contacts [contact@opencitations.net](mailto:contact@opencitations.net)
#endpoint https://w3id.org/oc/sparql
#addon occapi

#url /metadata/{dois}
#type operation
#dois str(\"?10\..+[^_\"]((__|\" \")10\..+[^_])*\"?)
#preprocess lower(dois) --> split_dois(dois)
#method get
#description This operation allows one to get the metadata of all the articles specified in input by means of their DOIs.

It is possible to specify one or more DOIs as input of this operation. In this case, the DOI should be separated with a double underscore ("__") – e.g. "10.1108/jd-12-2013-0166__10.1016/j.websem.2012.08.001__...".
#call /metadata/10.1108/jd-12-2013-0166__10.1016/j.websem.2012.08.001
#field_type str(author) datetime(year) str(title) str(source_title) str(volume) str(issue) str(page) str(doi) int(citation_count)
#output_json [
    {
        "author": "Peroni, S; Shotton, D",
        "doi": "10.1016/j.websem.2012.08.001",
        "year": "2012",
        "page": "33-43",
        "issue": "",
        "title": "FaBiO and CiTO: Ontologies for describing bibliographic resources and citations",
        "citation_count": "1",
        "source_title": "Web Semantics: Science, Services and Agents on the World Wide Web",
        "volume": "17"
    },
    {
        "author": "Peroni, S; Dutton, A; Gray, T; Shotton, D",
        "doi": "10.1108/jd-12-2013-0166",
        "year": "2015",
        "page": "253-277",
        "issue": "2",
        "title": "Setting our bibliographic references free: towards open citation data",
        "citation_count": "1",
        "source_title": "Journal of Documentation",
        "volume": "71"
    }
]
#sparql PREFIX cito: <http://purl.org/spar/cito/>
PREFIX dcterms: <http://purl.org/dc/terms/>
PREFIX fabio: <http://purl.org/spar/fabio/>
PREFIX frbr: <http://purl.org/vocab/frbr/core#>
PREFIX datacite: <http://purl.org/spar/datacite/>
PREFIX literal: <http://www.essepuntato.it/2010/06/literalreification/>
PREFIX pro: <http://purl.org/spar/pro/>
PREFIX oco: <https://w3id.org/oc/ontology/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX prism: <http://prismstandard.org/namespaces/basic/2.0/>

SELECT DISTINCT ?author ?year ?title ?source_title ?volume ?issue ?page ?doi ?citation_count
WHERE {
	VALUES ?doi { [[dois]] }

	?article a fabio:Expression ;
		datacite:hasIdentifier [
			datacite:usesIdentifierScheme datacite:doi ;
			literal:hasLiteralValue ?doi
		] .

	{
		SELECT ?article ?doi (count(?doi) as ?citation_count) {
			VALUES ?doi { [[dois]] }

			?article a fabio:Expression ;
					datacite:hasIdentifier [
						datacite:usesIdentifierScheme datacite:doi ;
						literal:hasLiteralValue ?doi
					] .

			OPTIONAL { ?article ^cito:cites ?other }
		} GROUP BY ?article ?doi
	}

	{
		SELECT ?article ?doi (GROUP_CONCAT(?a; separator="; ") as ?author) {
			VALUES ?doi { [[dois]] }

			{
			SELECT ?article ?doi ?a (count(?next) as ?tot) {
				VALUES ?doi { [[dois]] }

				?article a fabio:Expression ;
					datacite:hasIdentifier [
						datacite:usesIdentifierScheme datacite:doi ;
						literal:hasLiteralValue ?doi
					] .

				OPTIONAL {
					?article pro:isDocumentContextFor ?role .
					?role pro:withRole pro:author ; pro:isHeldBy [
						foaf:familyName ?f_name ;
						foaf:givenName ?g_name
					] .
					OPTIONAL { ?role oco:hasNext* ?next }
					BIND(CONCAT(?f_name, ", ", SUBSTR(?g_name, 0, 1)) as ?a)
				}
			} GROUP BY ?article ?doi ?a ORDER BY DESC(?tot)}
		} GROUP BY ?article ?doi
	}

	OPTIONAL { ?article ^cito:cites ?other }
	OPTIONAL { ?article dcterms:title ?title }
	OPTIONAL { ?article fabio:hasPublicationYear ?year }
	OPTIONAL {
		?article frbr:partOf+ ?source .
		FILTER NOT EXISTS {
			?source frbr:partOf ?another_source
		}
		?source dcterms:title ?source_title
	}
	OPTIONAL {
		?article frbr:partOf+ ?v .
		?v a fabio:JournalVolume ;
			fabio:hasSequenceIdentifier ?volume
	}
	OPTIONAL {
		?article frbr:partOf+ ?i .
		?i a fabio:JournalIssue ;
			fabio:hasSequenceIdentifier ?issue
	}
	OPTIONAL {
		?article frbr:embodiment ?man .
		?man prism:startingPage ?start .
		OPTIONAL { ?man prism:endingPage ?end }
		BIND (CONCAT(?start, IF(bound(?end), CONCAT("-", ?end), "")) as ?page)
	}
}
LIMIT 10000

#url /coauthorship/{dois}
#type operation
#dois str(\"?10\..+[^_\"]((__|\" \")10\..+[^_])*\"?)
#preprocess lower(dois) --> split_dois(dois)
#postprocess remove_duplicates()
#method get
#description This operation allows one to get co-authorship matrix of all the articles specified in input by means of their DOIs.

It is possible to specify one or more DOIs as input of this operation. In this case, the DOI should be separated with a double underscore ("__") – e.g. "10.1108/jd-12-2013-0166__10.1016/j.websem.2012.08.001__...".
#call /coauthorship/10.1108/jd-12-2013-0166__10.1016/j.websem.2012.08.001
#field_type str(author1) str(author2) int(coauthorship_count)
#output_json [
    {
        "author1": "Dutton, A",
        "author2": "Gray, T",
        "coauthorship_count": "1"
    },
    {
        "author1": "Dutton, A",
        "author2": "Peroni, S",
        "coauthorship_count": "1"
    },
    {
        "author1": "Dutton, A",
        "author2": "Shotton, D",
        "coauthorship_count": "1"
    },
    {
        "author1": "Gray, T",
        "author2": "Peroni, S",
        "coauthorship_count": "1"
    },
    {
        "author1": "Gray, T",
        "author2": "Shotton, D",
        "coauthorship_count": "1"
    },
    {
        "author1": "Peroni, S",
        "author2": "Shotton, D",
        "coauthorship_count": "2"
    }
]
#sparql PREFIX fabio: <http://purl.org/spar/fabio/>
PREFIX datacite: <http://purl.org/spar/datacite/>
PREFIX literal: <http://www.essepuntato.it/2010/06/literalreification/>
PREFIX pro: <http://purl.org/spar/pro/>
PREFIX oco: <https://w3id.org/oc/ontology/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

SELECT ?author1 ?author2 (count(?author1) as ?coauthorship_count) WHERE {
	VALUES ?doi { [[dois]] }

	?article a fabio:Expression ;
		datacite:hasIdentifier [
			datacite:usesIdentifierScheme datacite:doi ;
			literal:hasLiteralValue ?doi
		] ;

		pro:isDocumentContextFor ?auth1 , ?auth2 .

		?auth1 oco:hasNext+ ?auth2 .

		?auth1 pro:isHeldBy [
			foaf:givenName ?gn1 ;
			foaf:familyName ?fn1
		] .
		?auth2 pro:isHeldBy [
			foaf:givenName ?gn2 ;
			foaf:familyName ?fn2
		] .

	BIND (CONCAT(?fn1, ", ", SUBSTR(?gn1, 0, 1)) as ?author1) .
	BIND (CONCAT(?fn2, ", ", SUBSTR(?gn2, 0, 1)) as ?author2) .
}
GROUP BY ?author1 ?author2
LIMIT 10000
